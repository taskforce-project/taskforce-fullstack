name: ðŸ·ï¸ Version Management (Service-Specific)

on:
  pull_request:
    types: [opened, synchronize, labeled, unlabeled, reopened]
    branches:
      - dev
      - main

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  validate-service-labels:
    name: âœ… Validate Service Labels
    runs-on: ubuntu-latest
    steps:
      - name: Check for service release labels
        uses: actions/github-script@v7
        with:
          script: |
            const labels = context.payload.pull_request.labels.map(l => l.name);
            const serviceLabels = labels.filter(l => 
              l.startsWith('backend:release:') || 
              l.startsWith('frontend:release:') || 
              l.startsWith('landing:release:')
            );
            
            core.info(`ðŸ” Found ${serviceLabels.length} service release labels: ${serviceLabels.join(', ')}`);
            
            if (serviceLabels.length === 0) {
              core.setFailed('âŒ This PR must have at least one service release label (e.g., backend:release:minor, frontend:release:patch)');
              return false;
            }
            
            // VÃ©rifier qu'il n'y a pas plusieurs labels pour le mÃªme service
            const services = serviceLabels.map(l => l.split(':')[0]);
            const uniqueServices = [...new Set(services)];
            if (services.length !== uniqueServices.length) {
              core.setFailed(`âŒ Multiple release labels found for the same service. Each service can have only one release label.`);
              return false;
            }
            
            const validLabels = [
              'backend:release:major', 'backend:release:minor', 'backend:release:patch',
              'frontend:release:major', 'frontend:release:minor', 'frontend:release:patch',
              'landing:release:major', 'landing:release:minor', 'landing:release:patch'
            ];
            
            for (const label of serviceLabels) {
              if (!validLabels.includes(label)) {
                core.setFailed(`âŒ Invalid release label: ${label}. Must be one of: ${validLabels.join(', ')}`);
                return false;
              }
            }
            
            core.info(`âœ… Valid service release labels found: ${serviceLabels.join(', ')}`);
            return true;

  calculate-next-versions:
    name: ðŸ”¢ Calculate Next Versions
    runs-on: ubuntu-latest
    needs: validate-service-labels
    outputs:
      backend_version: ${{ steps.calc.outputs.backend_version }}
      frontend_version: ${{ steps.calc.outputs.frontend_version }}
      landing_version: ${{ steps.calc.outputs.landing_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Calculate versions
        id: calc
        uses: actions/github-script@v7
        with:
          script: |
            const branch = '${{ github.base_ref }}';
            const labels = context.payload.pull_request.labels.map(l => l.name);
            
            const services = ['backend', 'frontend', 'landing'];
            const versions = {};
            
            for (const service of services) {
              const releaseLabel = labels.find(l => l.startsWith(`${service}:release:`));
              if (!releaseLabel) continue;
              
              const increment = releaseLabel.split(':')[2]; // major, minor, patch
              
              // RÃ©cupÃ©rer le dernier tag du service
              const prefix = `${service}-v`;
              const { data: tags } = await github.rest.repos.listTags({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
              
              let latestTag = null;
              if (branch === 'dev') {
                latestTag = tags.find(t => t.name.startsWith(prefix) && t.name.includes('-rc'));
              } else {
                latestTag = tags.find(t => t.name.startsWith(prefix) && !t.name.includes('-rc'));
              }
              
              // Parser la version actuelle
              let major = 0, minor = 1, patch = 0, rc = 0;
              if (latestTag) {
                const match = latestTag.name.match(/v(\d+)\.(\d+)\.(\d+)(-rc(\d+))?/);
                if (match) {
                  major = parseInt(match[1]);
                  minor = parseInt(match[2]);
                  patch = parseInt(match[3]);
                  rc = match[5] ? parseInt(match[5]) : 0;
                }
              }
              
              // Calculer la nouvelle version
              if (branch === 'dev') {
                if (increment === 'major') {
                  major++; minor = 0; patch = 0; rc = 1;
                } else if (increment === 'minor') {
                  minor++; patch = 0; rc = 1;
                } else if (increment === 'patch') {
                  patch++; rc = 1;
                }
                versions[service] = `${service}-v${major}.${minor}.${patch}-rc${rc}`;
              } else {
                if (increment === 'major') {
                  major++; minor = 0; patch = 0;
                } else if (increment === 'minor') {
                  minor++; patch = 0;
                } else {
                  patch++;
                }
                versions[service] = `${service}-v${major}.${minor}.${patch}`;
              }
              
              core.info(`ðŸ“¦ ${service}: ${latestTag?.name || 'none'} â†’ ${versions[service]}`);
              core.setOutput(`${service}_version`, versions[service]);
            }

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const backendVer = '${{ steps.calc.outputs.backend_version }}';
            const frontendVer = '${{ steps.calc.outputs.frontend_version }}';
            const landingVer = '${{ steps.calc.outputs.landing_version }}';
            
            let message = '## ðŸ“¦ Version Preview\n\n';
            message += 'This PR will create the following versions:\n\n';
            
            if (backendVer) message += `- **Backend**: \`${backendVer}\`\n`;
            if (frontendVer) message += `- **Frontend**: \`${frontendVer}\`\n`;
            if (landingVer) message += `- **Landing**: \`${landingVer}\`\n`;
            
            message += '\n---\n';
            message += '_These versions will be created when this PR is merged._';
            
            // Rechercher un commentaire existant
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number
            });
            
            const botComment = comments.find(c => 
              c.user.type === 'Bot' && 
              c.body.includes('ðŸ“¦ Version Preview')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: message
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: message
              });
            }
